<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Border 的四种求法</title>
    <url>/post/four-ways-to-spell-border/</url>
    <content><![CDATA[<p>“我问你，border 有四种求法*，你知道么？”</p>
<p>*Border 的四种求法：指毛估，哈希，KMP 和 runs，其中最后一种求法极其罕见。</p>
<span id="more"></span>

<h3 id="Peroid-amp-Border"><a href="#Peroid-amp-Border" class="headerlink" title="Peroid &amp; Border"></a>Peroid &amp; Border</h3><ul>
<li>（Border）我们定义串 $s$ 的一个非空严格前缀 $s[:k]$ 是 $s$ 的 border，当且仅当 $s[:k]&#x3D;s[|s|-k+1:]$。注意这里 $k\in[1,|s|)$。</li>
</ul>
<p>Border 具有一个优良的性质：$s$ 的一个前缀在 $s$ 中的全部出现位置，即是其在 $s$ 的失配树上的子树中的所有节点。而实际上，失配树上一个节点的祖先，即是这个节点的最长 border 所代指的前缀。</p>
<p>这样我们可以利用这个性质解决一系列单模式匹配问题，唯一的需求是快速建立失配树的结构。</p>
<p>这可以用 KMP 算法来解决：维护当前匹配的最长 border $p$，考虑扩展出一个字符 $c$ 之后，只需要验证 $p$ 到根的这一段路径上，有没有一个节点的下一个字符是 $c$。我们暴力跳失配树，容易发现每条树边只会被经过 $O(1)$ 次，因此总复杂度是均摊 $O(n)$。</p>
<p>注意这里的 border 针对的是同一个串而言，当然我们也可以在不同串之间定义 border，这就出现了 AC 自动机（多模式匹配）和 KMP 自动机（可回撤匹配）等一系列结构。</p>
<p>Border 在扩展 KMP 算法中还体现了另一个应用，因为不是特别有启发性所以这里跳过。</p>
<ul>
<li>（周期）我们定义一个整数 $r\in [1,|s|]$ 是串 $s$ 的周期，当且仅当 $\forall i\in[1,|s|-r]$，满足 $s[i]&#x3D;s[i+r]$。我们称一个串所有周期中最小的那个为 $s$ 的最小周期，记作 $per(s)$。</li>
</ul>
<p>接下来证明一个结论：“$s[:k]$ 是 $s$ 的 border”等价于“$|s|-k$ 是 $s$ 的周期”。</p>
<p>考虑先证充分性，可以发现 $2k\le |s|$ 的情况是 trivial 的。我们考虑 $2k &gt; |s|$，此时设 $s&#x3D;XA$，其中 $|A|&#x3D;k$ 是 $s$ 的 border，可以发现 $X$ 必然是 $A$ 的严格前缀，那么去掉 $X$ 之后，可以转化为同样的问题，最后只会剩下 $X$ 的一段前缀。于是充分性得证，不难发现必要性也同理。</p>
<p>这意味着，一个串的所有周期和它的所有 border 是等价的集合。</p>
<p>关于周期，我们知道一些重要的结论：</p>
<ul>
<li>（Weak Periodicity Lemma）如果 $p,q$ 都是 $s$ 的周期，且满足 $p+q\le |s|$，那么 $(p,q)$ 也是 $s$ 的周期。</li>
<li>（Periodicity Lemma）如果 $p,q$ 都是 $s$ 的周期，且满足 $p+q-(p,q)\le |s|$，那么 $(p,q)$ 也是 $s$ 的周期。</li>
</ul>
<p>这意味这周期的出现是极其规律的。或者换个角度讲，border 的出现也是非常规律的！</p>
<p>可以发现如下规律：</p>
<ul>
<li>对于串 $a,b$，满足 $2|a|\ge b$，则 $a$ 在 $b$ 中的匹配位置构成一个公差为 $per(a)$ 的等差数列。</li>
<li>对于串 $s$，$s$ 的所有长度大于等于 $\frac{|s|}{2}$ 的 border 构成一个等差数列。</li>
<li>对于串 $s$，$s$ 的所有 border 排序后形成 $\log |s|$ 段等差数列。</li>
</ul>
<p>对于第一和第二个结论，可以通过 WPL 简单证明；而第三个结论只需再利用 “border 的 border 还是 border”这个性质即可证明。</p>
<h3 id="Runs-amp-Lyndon-Factorize"><a href="#Runs-amp-Lyndon-Factorize" class="headerlink" title="Runs &amp; Lyndon Factorize"></a>Runs &amp; Lyndon Factorize</h3><p>我们考虑从另一个角度理解周期，引入 runs 的概念：</p>
<ul>
<li>（Runs）我们定义一个三元组 $(l,r,p)$ 是 $s$ 的一个 run，当且仅当 $per(s[l:r])&#x3D;p$，且 $2p\le r-l+1$，且 $s[l:r]$ 是极长的一段最小周期为 $p$ 的串。特别的，实数 $\frac{r-l+1}{p}$ 称作一个 run 的指数。</li>
</ul>
<p>可以发现这个东西和周期联系密切，它的本质即是对极长严格周期串（即满足 $2per(s)\le |s|$）按照它们的最小周期分类。</p>
<ul>
<li>（The Runs Theorem）记 $\rho(n)$ 表示长为 $n$ 的串至多含有的 run 的数量，$\sigma(n)$ 表示长为 $n$ 的串所有 run 的指数和的最大值，那么有 $\rho(n)&lt;n,\sigma(n)\le 3n-3$。</li>
</ul>
<p>这意味着我们可以求出一个串的所有 run，考虑怎么求。</p>
<ul>
<li>（Lyndon 串）设 $&lt;_\iota$ 是比较运算符，其中 $\iota&#x3D;0&#x2F;1$，分别对应两种相反的比较，这里令 $&lt;_0\Leftrightarrow&lt;,&lt;_1\Leftrightarrow &gt;$。我们称 $s$ 是关于 $&lt;_\iota$ 的 Lyndon 串，当且仅当 $\forall i\in [2,|s|]$，满足 $s&lt;_\iota s[i:|s|]$。</li>
<li>（Lyndon 分解）称 $a_1a_2…a_n&#x3D;s$ 是 $s$ 关于 $&lt;_\iota$ 的 Lyndon 分解，当且仅当所有 $a_i$ 均是关于 $&lt;_\iota$ 的 Lyndon 串，且 $a_i\not&lt;_\iota a_{i+1}$。可以证明，一个串的 Lyndon 分解存在且唯一。</li>
<li>（Lyndon Root）称 $\lambda&#x3D;s[l_\lambda:r_\lambda]$ 是一个 run $u&#x3D;(l,r,p)$ 关于 $&lt;_\iota$ 的 Lyndon Root，当且仅当 $[l_\lambda:r_\lambda]\subseteq [l,r]$，且 $\lambda$ 是一个 Lyndon 串。</li>
</ul>
<p>考虑反过来求每个 Lyndon Root。</p>
<p>我们把串 Lyndon 分解，然后枚举一个 $i$，设 $ed[i]$ 是这一段 Lyndon 分解的边界，那么以 $i$ 开头的 Lyndon 子串的右端点不会超过 $ed[i]$，一段 Lyndon Root 也必然是 $s[i:ed[i]]$ 的子串。</p>
<p>我们从这里开始，二分哈希找到包含 $s[i:ed[i]]$ 的极长循环子串 $s[l:r]$。如果这段子串合法（满足 runs 的定义），那么就找到了一个 run。显然一个 $s[l:r]$ 可能被统计多次，我们应当取周期最小的那一次。</p>
<p>如果对 $\iota&#x3D;0&#x2F;1$ 均做一遍这样的操作，我们就可以得到所有的 run。</p>
<p>我们发现依赖 runs 具有的优良性质，可以解决一系列周期相关的问题以及 border 相关的问题。这种方法比 SAM 等常见处理办法更加简洁，在时间和空间上可以获得进一步的优化。</p>
<p>但是这也是有局限的，因为 runs 无法表出非严格周期串，否则复杂度就错了。</p>
<h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">

<p>给定一个仅包含小写拉丁字母的字符串 $s$。有 $q$ 次询问，每次询问形如 $(l,r)$，表示询问 $s[l:r]$ 这一段子串是否可以被表示成 $s[l:r]&#x3D;X^kX’$ 的形式，其中 $X$ 是任意字符串，$X’$ 是 $X$ 的可空前缀，$k\ge 2$。</p>
<p>对于每次询问，如果这样的 $X$ 存在，输出最短的 $X$ 的长度；否则，输出 $-1$。</p>
<p>全部数据满足 $|s|,q\le 10^6$，TL &#x3D; 2s(-O2) &#x2F; ML &#x3D; 128Mb。</p>
</div></article>

<p>显然求 $per(s[l:r])$ 等价于求 $s[l:r]$ 的最长 border，直接 KMP 即可 $O(q|s|)$。</p>
<p>求出 $s$ 的 runs，那么每次询问相当于矩形取 $\min$，直接离线二维数点即可，复杂度 $O((|s|+q)\log |s|)$。</p>
<p>需要特别说明的是，如果没有 $k\ge 2$ 的限制，那么本题相当于<a href="https://www.luogu.com.cn/problem/P4482">「BJWC2018」Border 的四种求法</a>，解法也不再这样简单。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《The Runs Theorem and Lyndon Tree》杨骏昭、徐翊轩、陈孙立，WC2019 讲稿</li>
</ul>
<p>相关题目：</p>
<ol>
<li>暂无来源</li>
</ol>
]]></content>
      <categories>
        <category>CP 笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title>template 的构建</title>
    <url>/post/template/</url>
    <content><![CDATA[<h2 id="形式幂级数与生成函数"><a href="#形式幂级数与生成函数" class="headerlink" title="形式幂级数与生成函数"></a>形式幂级数与生成函数</h2><h3 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h3><p>设 $z$ 是未定元，我们定义一个形式幂级数是一个无穷级数：</p>
<p>$$ A(z)&#x3D;a_0+a_1z^1+a_2z^2+…+a_nz^n+…&#x3D;\sum\limits_{i\ge 0} a_iz^i $$</p>
<p>其中 $\langle a_0,a_1,a_2,…\rangle$ 是一个无穷的实系数序列。</p>
<p>在这里，我们并不关心 $z$ 是否代入了某个值，它如同一个“占位符”，并不参与我们的运算。</p>
<h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><p>对于任意一个序列 $\langle g_0,g_1,g_2,…,g_n\rangle$，我们可以认为其不存在的项全部等于 0，然后将其看作一个无穷的数列。这样，我们可以定义这个数列的普通生成函数（Ordinary Generating Function, OGF）是一个形式幂级数：</p>
<p>$$G(z)&#x3D;\sum\limits_{i\ge 0} g_iz^i$$</p>
<p>可以定义这个数列的指数生成函数（Exponential Generating Funcion, EGF）是一个形式幂级数：</p>
<p>$$G(z)&#x3D;\sum\limits_{i\ge 0} \dfrac{g_iz^i}{i!}$$</p>
<p>这样我们就通过统一化的语言来表达了一个数列，而这就是生成函数的意义所在：解决数列问题的工具。</p>
<p>从另一种角度来讲，生成函数也可以看作一个次数是正无穷的多项式，因此生成函数的乘法即是多项式相乘。</p>
<p>一般情况下，我们只关心某个生成函数的前 $n$ 项系数，记作 $A(z)\text{ }\text{mod}\text{ } z^n$。这个形式对应了一个有限项的系数序列。</p>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="乘法卷积"><a href="#乘法卷积" class="headerlink" title="乘法卷积"></a>乘法卷积</h3><p>对于数列 $f,g$，我们定义它们的乘法卷积（或者直接称作卷积）是一个数列 $c$，满足：</p>
<p>$$ c_i&#x3D;\sum\limits_{j&#x3D;0}^i f_jg_{i-j}$$</p>
<p>同时记作 $c&#x3D;fg$。容易发现，两个数列乘法卷积的 OGF 是它们各自的 OGF 相乘得到的结果。</p>
<h3 id="二项卷积"><a href="#二项卷积" class="headerlink" title="二项卷积"></a>二项卷积</h3><p>对于数列 $f,g$，我们定义它们的二项卷积是一个数列 $c$，满足：</p>
<p>$$c_i&#x3D;\sum\limits_{j&#x3D;0}^i \dbinom{i}{j}f_jg_{i-j}$$</p>
<p>同时记作 $c&#x3D;fg$，这里乘法的定义与上面的不同，但是惯用记号一样，需要根据语境来区分。容易发现，两个数列二项卷积的 EGF 是它们的 EGF 相乘得到的结果。</p>
<h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>对于数列 $f,g$，我们定义它们的狄利克雷卷积是一个数列 $c$，满足：</p>
<p>$$c_i&#x3D;\sum\limits_{k|i} f_{k}g_{i&#x2F;k}$$</p>
<p>记号同上。狄利克雷卷积在数论中很常见。</p>
<p>类似的，我们可以定义异或卷积 $(fg)_i&#x3D;\sum\limits_{j\oplus k&#x3D;i} f_jg_k$，或卷积 $(fg)_i&#x3D;\sum\limits_{j\cup k&#x3D;i}f_jg_k$，与卷积 $(fg)_i&#x3D;\sum\limits_{j\cap k&#x3D;i} f_jg_k$，其中我们用 $\oplus$ 代表按位异或，用 $\cup$ 代表按位或，用 $\cap$ 代表按位与。</p>
<p>除去狄利克雷卷积可以直接 $O(n\ln n)$ 计算之外，其它卷积计算的朴素实现均是 $O(n^2)$ 的。因此我们需要通过下面的这些手段去计算卷积。</p>
<h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>离散傅里叶变换（Discrete Fourier Transform, DFT）是对多项式进行从系数表示到点值表示的变换。设 $f(x)$ 是一个 $n-1$ 次多项式，那么它的 DFT 对应一个长度为 $n$ 的序列 $\mathcal F(f)$，满足：</p>
<p>$$ \mathcal F(f)_i&#x3D;f(x_i) $$</p>
<p>其中 $x_i(i&#x3D;0,1,2,…,n-1)$ 是代入的点值。</p>
<p>快速傅里叶变换（Fast Fourier Transform, FFT）通过 $n$ 次单位根 $\omega_n$ 来进行 DFT，其中 $\omega_n$ 满足 $\omega_n^n&#x3D;1$；在复数域下，这样的数字一共有 $n$ 个。<br>如果令 $\omega_n^1&#x3D;\cos \frac{2\pi}{n}+i\sin\frac{2\pi}{n}$，那么它们分别是 $\omega_n^0,\omega_n^1,\omega_n^2,…,\omega_n^{n-1}$。</p>
<p>由于 $n$ 次单位根的一些特殊性质，所以当 $n&#x3D;2^k$ 时，我们可以通过分治来求解点值，以及通过点值来求解系数，后者称作逆变换（Inverse Discrete Fourier Transfrom, IDFT）。</p>
<p>这样就得到了一个在 $O(n\log n)$ 的时间内进行 DFT 的算法（FFT）。需要注意的一点是，如果用 FFT 计算序列卷积，得到的是长度为 $n$ 的循环卷积 $(fg)_i&#x3D;\sum\limits_{j+k\text{ }\text{mod }n&#x3D;i}f_jg_k$，用生成函数记作：</p>
<p>$$F(z)G(z)\text{ }\text{mod }z^n-1$$</p>
<p>FFT 的代码实现可以在模板梳理中找到。</p>
<h3 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h3><ul>
<li>原根：在 $\mathbb F_R$ 下，如果一个数 $g^i$ 一共有 $\varphi(R)$ 种不同的取值，或者说 $g$ 模 $R$ 的阶是 $\varphi(R)$，那么称 $g$ 是 $\mathbb F_R$ 下的原根。</li>
</ul>
<p>可以证明，原根存在的充要条件是 $R&#x3D;2,4,p^a,2p^a$，其中 $p$ 是一个素数。可以发现，素数的原根是总存在的。</p>
<p>考虑做长度为 $n&#x3D;2^k$ 的 DFT，有没有什么方式可以避免复数运算？</p>
<p>对于形如 $P&#x3D;a2^r+1(r\ge k)$ 的素数，设 $g$ 是 $\mathbb F_P$ 下的原根，那么 $g_n&#x3D;g^{\varphi(P)&#x2F;n}$ 有着与 $n$ 次单位根 $\omega_n$ 相同的性质，即 $g_n^n&#x3D;1$。根据原根的性质，我们可以发现 $g_n^0,g_n^1,…,g_n^{n-1}$ 是 $n$ 个两两不同的数字，且都满足 $(g_n^l)^n\equiv g^{l\varphi(P)}\equiv 1\text{ }(\text{mod }P)$。于是，我们可以用 $g_n$ 来代替 $\omega_n$ 进行多项式变换，这样就得到了快速数论变换，本质上是 FFT 在模域下的变种。</p>
<p>一个质数的原根一定存在，但并不是只要存在原根就可以 NTT，另一个条件是 $n|\varphi(P)$，形象的理解即可以等分圆周。</p>
<p>代码同样可以在模板梳理中找到。</p>
<p>值得一提的是，这种计算点值的方法与单位根反演有着异曲同工之妙。单位根反演即是这个柿子：</p>
<p>$$[k|n]&#x3D;\dfrac{1}{k}\sum\limits_{i&#x3D;0}^{k-1}\omega_k^{in}$$</p>
<p>其中 $\omega_k$ 是 $k$ 次单位根，模义下可用 $g_k$ 来代替；这可以看作是计算了一个点值，在一些题目中会具有优良的性质。</p>
<h3 id="离散沃尔什变换"><a href="#离散沃尔什变换" class="headerlink" title="离散沃尔什变换"></a>离散沃尔什变换</h3><p>显然，位运算卷积不满足卷积结果的点值是原点值相乘。那么我们可以通过一些手段构造某种变换，来让我们变换出的序列满足点值相乘的规律。这些变换分别是：</p>
<ul>
<li>按位或</li>
</ul>
<p>$$\mathcal{F}(f)_i&#x3D;\sum\limits_{j\cup i&#x3D;i}a_j$$</p>
<ul>
<li>按位与</li>
</ul>
<p>$$\mathcal{F}(f)_i&#x3D;\sum\limits_{j\cap i&#x3D;i}a_j$$</p>
<ul>
<li>按位异或</li>
</ul>
<p>$$\mathcal{F}(f)_i&#x3D;\sum\limits_{j&#x3D;0}^{n-1} (-1)^{|i\cap j|} f_j$$</p>
<p>其中 $|x|$ 代表 $x$ 在二进制下为 1 的位数。可以证明，这些变换满足与 DFT 同样的性质，即点值的乘积是卷积结果的点值。</p>
<p>对于异或的变换，还有一个重要的柿子是 $\mathcal{F}(\mathcal{F}(f))_i&#x3D;n·f_i$，可以通过代入化简来证明。</p>
<p>这些变换都可以通过类似 FFT 的方法在 $O(n\log n)$ 的时间内得到。代码可以参考模板梳理。</p>
<h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><p>形式幂级数的微分定义为逐项微分，即：</p>
<p>$$\dfrac{\text d}{\text dz} \left(\sum\limits_{i\ge 0} a_iz^i \right)&#x3D;\sum\limits_{i\ge 0} (i+1)a_{i+1}z^i$$</p>
<p>同样的，形式幂级数的积分定义为逐项积分。我们可以定义一个形式幂级数的定积分为：</p>
<p>$$\int \left(\sum\limits_{i\ge 0}a_iz^i \right)\text dz&#x3D;\sum\limits_{i&gt;0}\dfrac{a_{i-1}}{i}z^i$$</p>
<p>我们可以用微积分来分析一个幂级数的闭合形式，这在涉及指标变换的时候较为方便。</p>
<h2 id="乘法逆"><a href="#乘法逆" class="headerlink" title="乘法逆"></a>乘法逆</h2><p>对于幂级数 $A(z)$，我们定义它的乘法逆是一个幂级数 $B(z)$ 满足 $A(z)B(z)\equiv 1 \text{ }(\text{mod } z^n)$，记作 $B(z)&#x3D;A^{-1}(z)$。</p>
<p>当 $A(z)$ 的常数项不为零时，它的乘法逆是总存在的。证明如下：</p>
<p>设 $A(z)&#x3D;\sum\limits_{i&#x3D;0}^{n-1} a_ix^i, B(z)&#x3D;\sum\limits_{i&#x3D;0}^{n-1} b_ix^i$，通过乘法逆的定义可得：</p>
<p>$$\begin{align} &amp;b_0&#x3D;\dfrac{1}{a_0}\newline &amp;\sum\limits_{j&#x3D;1}^{n-1} a_jb_{i-j}&#x3D;0\text{ }(i&gt;0)\end{align}$$</p>
<p>对 $i$ 归纳可以得到：</p>
<p>$$ b_i&#x3D;-b_0\sum\limits_{j&#x3D;0}^{i-1}a_{i-j}b_j\text{ }(i&gt;0) $$</p>
<p>从而只要 $b_0$ 存在就可以构造出 $B(z)$。同时这也给出了朴素 $O(n^2)$ 求逆的方法，下一步考虑怎么优化。</p>
<p>设 $B_0(z)&#x3D;A^{-1}(z)\text{ }\text{mod } z^n$ 是一个只有前 $n$ 项系数有效的幂级数，可以如下倍增：</p>
<p>$$\begin{align} B_0(z)A(z)&amp;\equiv 1\text{ }(\text{mod } z^n)\newline    (B_0(z)A(z)-1)^2&amp;\equiv 0\text{ }(\text{mod }z^{2n})\newline    B_0^2(z)A^2(z)-2B_0(z)A(z)+1&amp;\equiv 0\text{ }(\text{mod }z^{2n}) \newline    B_0(z)(2-B_0(z)A(z))&amp;\equiv B(z)\text{ }(\text{mod }z^{2n}) \end{align}$$</p>
<p>其中 $B(z)&#x3D;A^{-1}(z)\text{ }\text{mod } z^{2n}$ 是一个只有前 $2n$ 项系数有效的幂级数。</p>
<p>依此倍增，复杂度 $T(n)&#x3D;T(n&#x2F;2)+O(n\log n)&#x3D;O(n\log n)$，实现可以在代码梳理中找到。</p>
<h2 id="指对运算"><a href="#指对运算" class="headerlink" title="指对运算"></a>指对运算</h2><h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><p>对一个高阶可导的函数 $f(x)$，它在 $x&#x3D;x_0$ 处的泰勒展开式为：</p>
<p>$$f(x)&#x3D;f(x_0)+f’(x_0)(x-x_0)+\dfrac{f’’(x_0)(x-x_0)^2}{2}+…+\dfrac{f^{(n)}(x-x_0)^n}{n!}+…$$</p>
<p>这是一个无穷级数。也可以只保留前 $n+1$ 项写作：</p>
<p>$$f(x)&#x3D;f(x_0)+f’(x_0)(x-x_0)+\dfrac{f’’(x_0)(x-x_0)}{2}+…+\dfrac{f^{(n)}(x_0)}{n!}+r_n(x)$$</p>
<p>其中 $r_n(x)$ 指代一个余项。</p>
<h3 id="麦克劳林公式"><a href="#麦克劳林公式" class="headerlink" title="麦克劳林公式"></a>麦克劳林公式</h3><p>在泰勒展开的公式中，取 $x_0&#x3D;0$，就得到了麦克劳林公式：</p>
<p>$$f(x)&#x3D;f(0)+f’(0)x+\dfrac{f’’(0)x^2}{2!}+…+\dfrac{f^{(n)}(0)x^n}{n!}+…$$</p>
<p>亦即 $f(x)$ 在 $x&#x3D;0$ 处的泰勒展开。</p>
<p>形式幂级数的乘方是有定义的，那么我们可以通过泰勒展开来定义如何对形式幂级数进行各种诡异的函数变换，诸如指对函数，正余弦函数，等等。</p>
<h3 id="指数函数和对数函数"><a href="#指数函数和对数函数" class="headerlink" title="指数函数和对数函数"></a>指数函数和对数函数</h3><p>由于 $(e^x)’&#x3D;e^x$，根据麦克劳林公式，可以得到：</p>
<p>$$\exp x&#x3D;e^x&#x3D;1+x+\dfrac{x^2}{2!}+\dfrac{x^3}{3!}…$$ </p>
<p>这是一个无穷级数。于是可以定义一个形式幂级数的指数函数为：</p>
<p>$$\exp A(z)&#x3D;\sum\limits_{i\ge 0}\dfrac{A^i(z)}{i!}$$</p>
<p>同理，因为：</p>
<p>$$\ln’ x&#x3D;x^{-1},\ln &#39;&#39;x&#x3D;-x^{-2},…,,\ln^{(n)} x&#x3D;(-1)^{n-1}(n-1)!(1+x)^{-n}$$</p>
<p>可以定义一个形式幂级数的对数函数是：</p>
<p>$$\ln (1+A(z))&#x3D;-\sum\limits_{i&gt;0}\dfrac{(-1)^iA^i(z)}{i}$$</p>
<p>注意这里的常数项是未定义的，一般认为其等于 0。</p>
<p>考虑如何求对数函数。设 $B(z)&#x3D;\ln A(z)$，两边求导得到：</p>
<p>$$B’(z)&#x3D;\ln’ A(z)&#x3D;\dfrac{A’(z)}{A(z)}$$</p>
<p>即是链式法则。于是我们只需要求逆即可，复杂度 $O(n\log n)$。</p>
<p>多项式指数的计算需要用到牛顿迭代。</p>
<h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>考虑计算一个函数 $f(x)$ 的零点。设 $x_0$ 是一个已知的近似解，在 $x_0$ 处对 $f(x)$ 泰勒展开，可以得到 $f(x)$ 的一个近似表达：</p>
<p>$$ f(x)\sim f(x_0)+f’(x_0)(x-x_0) $$</p>
<p>令 $f(x_0)+f’(x_0)(x-x_0)&#x3D;0$，解得 $x&#x3D;x_0-\dfrac{f(x_0)}{f’(x_0)}$。取 $x$ 作为下一个近似解 $x_2$，又可以进行同样的操作。可以证明，在某些情况下，这样就可以逼近 $f(x)$ 精确的零点。</p>
<p>设 $B(z)&#x3D;\exp A(z)$，那么有 $\ln B(z)-A(z)&#x3D;0$。设 $G(B(z))&#x3D;\ln B(z)-A(z)$ 是一个以 $B(z)$ 为变元的形式幂级数，$B_0(z)&#x3D;\exp A(z)\text{ }\text{mod }z^n$ 是已知的近似解，那么可以如下倍增（迭代）：</p>
<p>$$\begin{align} B(z)&amp;\equiv B_0(z)-\dfrac{\ln B_0(z)-A(z)}{1&#x2F;B_0(z)}\text{ }(\text{mod } z^{2n})\newline    &amp;\equiv B_0(z)(1-\ln B_0(z)+A(z))\text{ }(\text{mod } z^{2n})\end{align}$$</p>
<p>依此迭代，复杂度 $T(n)&#x3D;T(n&#x2F;2)+O(n\log n)&#x3D;O(n\log n)$，实现可以在代码梳理中找到。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>请构造一个序列 $a_1,a_2,…,a_k$，满足 $\forall i\in[1, k] a_i\in[1, n]$，使得对这个序列做无限背包计数后得到的序列的前 $n$ 项在模 $P$ 意义下是 $f_1,f_2,…,f_n$，其中 $P$ 是一个给定的质数。序列的长度没有限制，可以证明解总存在且唯一。</p>
<p>$n\le 2^{18},10^6\le p\le 2^{30}$</p>
</div></article>

<p>设 $b_i$ 表示序列中是否包含 $i$ 这个数字，$F(z)&#x3D;\sum\limits_{i&#x3D;1}^n f_iz^i$，那么有：</p>
<p>$$\begin{align} F(z)&amp;&#x3D;\prod\limits_{i&#x3D;1}^n \dfrac{1}{(1-z^i)^{b_i}}\newline    \ln F(z)&amp;&#x3D;-\sum\limits_{i&#x3D;1}^nb_i\ln(1-z^i)\newline    \ln F(z)&amp;&#x3D;\sum\limits_{i&#x3D;1}^nb_i\sum\limits_{j&gt;0}\dfrac{z^{ij}}{j}\newline    &amp;&#x3D;\sum\limits_{i&#x3D;1}^n z^i\sum\limits_{j|i}\dfrac{jb_j}{i}  \end{align}$$</p>
<p>比较系数得 $nf_n&#x3D;\sum\limits_{i|n}ib_i$，亦即 $f&#x3D;b*1$，莫比乌斯反演得 $b_n&#x3D;\dfrac{1}{n}\sum\limits_{j|n}jf_j\varphi(n&#x2F;j)$。</p>
<p>复杂度 $O(n(\log n+\ln n))$，需要任意模数卷积，这里用拆系数 FFT 实现。</p>
<p>代码：</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LDB long double</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> CN = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">18</span>) + <span class="hljs-number">3</span>;
<span class="hljs-type">const</span> LDB PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);
<span class="hljs-type">int</span> P;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>, ne = <span class="hljs-number">1</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">for</span>(;c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) ne = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(;c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) s = (s &lt;&lt; <span class="hljs-number">1</span>) + (s &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-string">&#x27;0&#x27;</span>;
    <span class="hljs-keyword">return</span> s * ne;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;
    <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; 
    <span class="hljs-keyword">while</span>(b)&#123;
        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) r = <span class="hljs-number">1ll</span> * r * a % P;
        a = <span class="hljs-number">1ll</span> * a * a % P, b &gt;&gt;= <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> r;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">invx</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x, P - <span class="hljs-number">2</span>);&#125;
<span class="hljs-keyword">namespace</span> POLY&#123;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">COMP</span>&#123;
        <span class="hljs-keyword">public</span>: LDB x, y;
        COMP <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> COMP &amp;o) <span class="hljs-type">const</span>&#123;
            COMP r = *<span class="hljs-keyword">this</span>; r.x += o.x, r.y += o.y;
            <span class="hljs-keyword">return</span> r;
        &#125;
        COMP <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> COMP &amp;o) <span class="hljs-type">const</span>&#123;
            COMP r = *<span class="hljs-keyword">this</span>; r.x -= o.x, r.y -= o.y;
            <span class="hljs-keyword">return</span> r;
        &#125;
        COMP <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> COMP &amp;o) <span class="hljs-type">const</span>&#123;
            COMP r; r.x = x * o.x - y * o.y, r.y = x * o.y + y * o.x;
            <span class="hljs-keyword">return</span> r;
        &#125;
    &#125; ;
    <span class="hljs-function">COMP <span class="hljs-title">mk</span><span class="hljs-params">(LDB a, LDB b)</span> </span>&#123;COMP o; o.x = a, o.y = b; <span class="hljs-keyword">return</span> o;&#125;
    <span class="hljs-function">COMP <span class="hljs-title">conj</span><span class="hljs-params">(COMP o)</span> </span>&#123;o.y = -o.y; <span class="hljs-keyword">return</span> o;&#125;
    <span class="hljs-type">int</span> rev[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cg</span><span class="hljs-params">(COMP t[], <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (n &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">if</span>(i &lt; rev[i]) <span class="hljs-built_in">swap</span>(t[i], t[rev[i]]);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(COMP t[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> tp)</span></span>&#123;
        <span class="hljs-built_in">cg</span>(t, n); 
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt;= n; w &lt;&lt;= <span class="hljs-number">1</span>)&#123;
            <span class="hljs-type">int</span> l = w &gt;&gt; <span class="hljs-number">1</span>; COMP gn = <span class="hljs-built_in">mk</span>(<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * PI / (LDB)w), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * tp * PI / (LDB)w));
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += w)&#123;
                COMP g = <span class="hljs-built_in">mk</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; i + l; j++)&#123;
                    COMP u = t[j], v = t[j + l] * g;
                    t[j] = u + v, t[j + l] = u - v, g = g * gn;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(tp ^ <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) t[i].x /= (LDB)n, t[i].y /= (LDB)n;
        &#125;
    &#125;
    COMP p[CN &lt;&lt; <span class="hljs-number">2</span>], q[CN &lt;&lt; <span class="hljs-number">2</span>], x[CN &lt;&lt; <span class="hljs-number">2</span>], y[CN &lt;&lt; <span class="hljs-number">2</span>], z[CN &lt;&lt; <span class="hljs-number">2</span>], w[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">conv</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// a = a * b</span>
        <span class="hljs-type">int</span> B = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>) - <span class="hljs-number">1</span>, N = <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(N &lt; (n &lt;&lt; <span class="hljs-number">1</span>)) N &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) p[i] = q[i] = <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); 
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p[i] = <span class="hljs-built_in">mk</span>(a[i] &gt;&gt; <span class="hljs-number">15</span>, a[i] &amp; B); <span class="hljs-comment">// k1 r1</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) q[i] = <span class="hljs-built_in">mk</span>(b[i] &gt;&gt; <span class="hljs-number">15</span>, b[i] &amp; B); <span class="hljs-comment">// k2 r2</span>
        <span class="hljs-built_in">fft</span>(p, N, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(q, N, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;
            <span class="hljs-type">int</span> j = (N - <span class="hljs-number">1</span>) &amp; (N - i);
            COMP k1, r1, k2, r2;
            k1 = (p[i] + <span class="hljs-built_in">conj</span>(p[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>);
            r1 = (p[i] - <span class="hljs-built_in">conj</span>(p[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-0.5</span>);
            k2 = (q[i] + <span class="hljs-built_in">conj</span>(q[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>);
            r2 = (q[i] - <span class="hljs-built_in">conj</span>(q[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-0.5</span>);
            x[i] = k1 * k2, y[i] = r1 * r2, z[i] = k1 * r2, w[i] = k2 * r1;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) p[i] = x[i] + y[i] * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) q[i] = z[i] + w[i] * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
        <span class="hljs-built_in">fft</span>(p, N, <span class="hljs-number">-1</span>), <span class="hljs-built_in">fft</span>(q, N, <span class="hljs-number">-1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;
            LL X = (LL)(<span class="hljs-number">0.5</span> + p[i].x), Y = (LL)(<span class="hljs-number">0.5</span> + p[i].y), Z = (LL)(<span class="hljs-number">0.5</span> + q[i].x), W = (LL)(<span class="hljs-number">0.5</span> + q[i].y);
            X = (X % P + P) % P, Y = (Y % P + P) % P, Z = (Z % P + P) % P, W = <span class="hljs-built_in">add</span>((W % P + P) % P, Z);
            a[i] = <span class="hljs-built_in">add</span>((X &lt;&lt; <span class="hljs-number">30</span>) % P, <span class="hljs-built_in">add</span>((W &lt;&lt; <span class="hljs-number">15</span>) % P, Y));
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &lt; N; i++) a[i] = <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-type">int</span> c[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n &lt;&lt; <span class="hljs-number">1</span>); i++) b[i] = c[i] = <span class="hljs-number">0</span>;
        b[<span class="hljs-number">0</span>] = <span class="hljs-built_in">invx</span>(a[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt; (n &lt;&lt; <span class="hljs-number">1</span>); w &lt;&lt;= <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) c[i] = a[i];
            <span class="hljs-built_in">conv</span>(c, b, w);
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) c[i] = <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, P - c[i]); c[<span class="hljs-number">0</span>] = <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, c[<span class="hljs-number">0</span>]);
            <span class="hljs-built_in">conv</span>(b, c, w);
        &#125;    
    &#125;
    <span class="hljs-type">int</span> ia[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ln</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n &lt;&lt; <span class="hljs-number">1</span>); i++) ia[i] = b[i] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">inv</span>(a, ia, n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n &lt;&lt; <span class="hljs-number">1</span>); i++) c[i] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) c[i] = <span class="hljs-number">1ll</span> * (i + <span class="hljs-number">1</span>) * a[i + <span class="hljs-number">1</span>] % P;
        <span class="hljs-built_in">conv</span>(c, ia, n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) b[i] = <span class="hljs-number">1ll</span> * c[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">invx</span>(i) % P;
    &#125;
&#125;
<span class="hljs-type">int</span> p[CN], mu[CN]; <span class="hljs-type">bool</span> np[CN];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;
    np[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;
        <span class="hljs-keyword">if</span>(!np[i]) p[++p[<span class="hljs-number">0</span>]] = i, mu[i] = P - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p[<span class="hljs-number">0</span>] &amp;&amp; i * p[j] &lt;= n; j++)&#123;
            <span class="hljs-type">int</span> x = i * p[j]; np[x] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(i % p[j]) mu[x] = P - mu[i];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;
<span class="hljs-type">int</span> n, a[CN &lt;&lt; <span class="hljs-number">2</span>], b[CN &lt;&lt; <span class="hljs-number">2</span>]; 
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span>
    n = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>, P = <span class="hljs-built_in">read</span>();
    a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) a[i] = <span class="hljs-built_in">read</span>();
    POLY :: <span class="hljs-built_in">ln</span>(a, b, n);
    <span class="hljs-built_in">sieve</span>(n), <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) b[i] = <span class="hljs-number">1ll</span> * b[i] * i % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; i * j &lt; n; j++)
        a[i * j] = <span class="hljs-built_in">add</span>(a[i * j], <span class="hljs-number">1ll</span> * mu[i] * b[j] % P);
    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) cnt += (!!a[i]);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span>(a[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>有一个整数 $x$，初值是 $[0,n]$ 内的一个随机值，其中为 $i$ 的概率为 $p_i$。<br>要进行 $m$ 轮操作，每次把 $x$ 等概率随机地替换成 $[0,x]$ 中的一个数字，求最后对 $\forall i\in[0, n]$，$x$ 的取值为 $i$ 的概率。对 $998244353$ 取模。</p>
<p>$n\le 10^5,m\le 10^{18}$</p>
</div></article>

<p>设 $f[k,i]$ 表示经过 $k$ 轮，得到 $i$ 的概率，有递推关系 $f[k,i]&#x3D;\sum\limits_{j\ge i}^n f[k-1,j]&#x2F;j+1$。</p>
<p>设 $F(k,z)&#x3D;\sum\limits_{i&#x3D;0}^n f[k,i]z^i$ 是 $f$ 的 OGF，根据上面的递推关系，有：</p>
<p>$$\begin{aligned} F(k,z)&amp;&#x3D;\sum\limits_{i&#x3D;0}^n z^i\sum\limits_{j&#x3D;i}^n \dfrac{f[k-1,j]}{j+1}\newline    &amp;&#x3D;\sum\limits_{j&#x3D;0}^n \dfrac{f[k-1,j]}{j+1}\sum\limits_{i&#x3D;0}^j z^i \newline  &amp;&#x3D;\dfrac{1}{z-1} \sum\limits_{i&#x3D;0}^n f[k-1,i]\dfrac{z^{i+1}-1}{i+1} \end{aligned}$$</p>
<p>考虑 $f[k-1,i]$ 转移到了哪里，容易发现它在 $F(k,·)$ 中是 $i+1$ 项系数，这个变换不容易快速实现，那么继续推导。</p>
<p>根据牛顿-莱布尼茨公式，可以推得：<br>$\int_1^z t^i\text{ }\text dt&#x3D;\dfrac{z^{i+1}}{z-1}-\dfrac{1}{z-1}$，那么原式化为：</p>
<p>$$\begin{aligned} F(k,z)&amp;&#x3D;\dfrac{1}{z-1}\sum\limits_{i&#x3D;0}^n f[k-1,i]\int_1^z t^i\text{ }\text dt\newline   &amp;&#x3D;\dfrac{1}{z-1}\int_1^z\left( \sum\limits_{i&#x3D;0}^nf[k-1,i]t^i\right)\text{ }\text dt\newline   &amp;&#x3D; \dfrac{1}{z-1}\int_1^z F(k-1,t)\text{ }\text dt  \end{aligned}$$</p>
<p>考虑原式中 $z^{i+1}-1$ 很是鬼畜，考虑把定积分的下指标改为从 0 开始，那么设 $G(k,z)&#x3D;F(k,z+1)$，有：</p>
<p>$$\begin{aligned} G(k,z)&amp;&#x3D;\dfrac{1}{z}\int_1^{z+1} F(k-1,t)\text{ }\text dt \newline   &amp;&#x3D;\dfrac{1}{z}\int_0^z F(k-1,t+1)\text{ }\text d(t+1)\newline   &amp;&#x3D;\dfrac{1}{z}\int_0^z G(k-1,t)\text{ }\text dt \newline    &amp;&#x3D; \dfrac{1}{z}\sum\limits_{i&#x3D;0}^n \dfrac{g[k-1,i]}{i+1}z^{i+1}\newline    &amp;&#x3D;\sum\limits_{i&#x3D;0}^n \dfrac{g[k-1,i]}{i+1}z^i \end{aligned}$$</p>
<p>其中 $g[k,i]$ 满足 $G(k,z)&#x3D;\sum\limits_{i&#x3D;0}^n g[k,i]z^i$，即是对应的序列。<br>考虑系数的变化：$k\to k+1:g[k,i]\to g[k+1,i]&#x2F;(i+1)$，那么 $m$ 次变化之后就是 $g[m,i]&#x3D;\dfrac{g[0,i]}{(i+1)^m}$ 这个就可以近似线性直接求出来。</p>
<p>那么只需要类似于 DFT 和 IDFT 那样子，把 $F$ 变成 $G$，系数修改完之后再变回来即可。</p>
<p>考虑怎么变，根据定义，得到：</p>
<p>$$\begin{aligned} G(k,z)&amp;&#x3D;F(k,z+1)\newline    \Leftrightarrow \sum\limits_{i&#x3D;0}^n g[k,i]z^i&amp;&#x3D;\sum\limits_{i&#x3D;0}^n f[k,i](z+1)^i\newline    &amp;&#x3D;\sum\limits_{i&#x3D;0}^n\sum\limits_{j&#x3D;0}^i\dbinom{i}{j}z^jf[k,i] \newline    &amp;&#x3D; \sum\limits_{i&#x3D;0}^n z^i \sum\limits_{j&#x3D;i}^n \dbinom{j}{i}f[k,j]\end{aligned}$$</p>
<p>考虑 $k&#x3D;0$，得：</p>
<p>$$\begin{aligned} g[0,i]&amp;&#x3D;\sum\limits_{j&#x3D;i}^n \dbinom{j}{i}p_j\newline    &amp;&#x3D; \dfrac{1}{i!}\sum\limits_{t&#x3D;0}^{n-i} \dfrac{(i+t)!p_{i+t}}{t!}\end{aligned}$$</p>
<p>这里是差为定值的卷积，依然可以化成序列卷积，那么构造 $A(z)&#x3D;\sum\limits_{i&#x3D;0}^n \dfrac{1}{i!},B(z)&#x3D;\sum\limits_{i&#x3D;0}^n b_ix^i$，其中有 $p_ii!&#x3D;b_{n-i}$，即人为令下标的和为定值，那么容易发现 $g[0,i]&#x3D;\dfrac{1}{i!}[z^{n-i}]A(z)B(z)$。NTT 即可，复杂度 $O(n\log n)$。</p>
<p>对于 $g\to f$ 的转化，根据二项式反演，有：</p>
<p>$$\begin{aligned} g[k,i]&amp;&#x3D;\sum\limits_{j&#x3D;i}^n\dbinom{j}{i}f[k,j] \newline    \Leftrightarrow f[k,i]&amp;&#x3D;\sum\limits_{j&#x3D;i}^n (-1)^{j-i}\dbinom{j}{i}g[k,j] \end{aligned}$$</p>
<p>依然是差为定值的卷积，同理可仿照上面求出，总复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> CN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;
<span class="hljs-function">LL <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;
    LL s = <span class="hljs-number">0</span>, ne = <span class="hljs-number">1</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">for</span>(;c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) ne = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(;c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) s = (s &lt;&lt; <span class="hljs-number">1</span>) + (s &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-string">&#x27;0&#x27;</span>;
    <span class="hljs-keyword">return</span> s * ne;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;
    <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(b)&#123;
        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) r = <span class="hljs-number">1ll</span> * r * a % P;
        a = <span class="hljs-number">1ll</span> * a * a % P, b &gt;&gt;= <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> r;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x, P - <span class="hljs-number">2</span>);&#125;
<span class="hljs-type">int</span> rev[CN &lt;&lt; <span class="hljs-number">2</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cg</span><span class="hljs-params">(<span class="hljs-type">int</span> t[], <span class="hljs-type">int</span> n)</span></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (n &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">if</span>(i &lt; rev[i]) <span class="hljs-built_in">swap</span>(t[i], t[rev[i]]);
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(<span class="hljs-type">int</span> t[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> tp)</span></span>&#123;
    <span class="hljs-built_in">cg</span>(t, n);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt;= n; w &lt;&lt;= <span class="hljs-number">1</span>)&#123;
        <span class="hljs-type">int</span> l = w &gt;&gt; <span class="hljs-number">1</span>, gn = <span class="hljs-built_in">qp</span>(tp ? <span class="hljs-number">3</span> : <span class="hljs-built_in">inv</span>(<span class="hljs-number">3</span>), (P - <span class="hljs-number">1</span>) / w);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += w)&#123;
            <span class="hljs-type">int</span> g = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; i + l; j++)&#123;
                <span class="hljs-type">int</span> u = t[j], v = <span class="hljs-number">1ll</span> * g * t[j + l] % P;
                t[j] = <span class="hljs-built_in">add</span>(u, v), t[j + l] = <span class="hljs-built_in">add</span>(u, P - v), g = <span class="hljs-number">1ll</span> * g * gn % P;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(!tp)&#123;
        <span class="hljs-type">int</span> in = <span class="hljs-built_in">inv</span>(n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) t[i] = <span class="hljs-number">1ll</span> * t[i] * in % P;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">conv</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// A = A * B</span>
    <span class="hljs-type">int</span> N = <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(N &lt; (n &lt;&lt; <span class="hljs-number">1</span>)) N &lt;&lt;= <span class="hljs-number">1</span>;
    <span class="hljs-built_in">ntt</span>(A, N, <span class="hljs-number">1</span>), <span class="hljs-built_in">ntt</span>(B, N, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) A[i] = <span class="hljs-number">1ll</span> * A[i] * B[i] % P;
    <span class="hljs-built_in">ntt</span>(A, N, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &lt; N; i++) A[i] = B[i] = <span class="hljs-number">0</span>;
&#125;
<span class="hljs-type">int</span> A[CN &lt;&lt; <span class="hljs-number">2</span>], B[CN &lt;&lt; <span class="hljs-number">2</span>];
<span class="hljs-type">int</span> n, m, p[CN], fac[CN], ifac[CN], g[CN];
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span>
    n = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>, m = <span class="hljs-built_in">read</span>() % (P - <span class="hljs-number">1</span>);
    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) fac[i] = <span class="hljs-number">1ll</span> * fac[i - <span class="hljs-number">1</span>] * i % P;
    ifac[n - <span class="hljs-number">1</span>] = <span class="hljs-built_in">inv</span>(fac[n - <span class="hljs-number">1</span>]); <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i + <span class="hljs-number">1</span>; i--) ifac[i] = <span class="hljs-number">1ll</span> * ifac[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p[i] = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) A[n - i - <span class="hljs-number">1</span>] = <span class="hljs-number">1ll</span> * fac[i] * p[i] % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) B[i] = ifac[i];
    <span class="hljs-built_in">conv</span>(A, B, n); 
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) g[i] = <span class="hljs-number">1ll</span> * ifac[i] * A[n - i - <span class="hljs-number">1</span>] % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) g[i] = <span class="hljs-number">1ll</span> * g[i] * <span class="hljs-built_in">inv</span>(<span class="hljs-built_in">qp</span>(i + <span class="hljs-number">1</span>, m)) % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) A[n - i - <span class="hljs-number">1</span>] = <span class="hljs-number">1ll</span> * fac[i] * g[i] % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) B[i] = i &amp; <span class="hljs-number">1</span> ? P - ifac[i] : ifac[i];
    <span class="hljs-built_in">conv</span>(A, B, n);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">int</span>(<span class="hljs-number">1ll</span> * ifac[i] * A[n - i - <span class="hljs-number">1</span>] % P)); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《生成函数的运算与组合计数问题》金策，IOI中国国家候选队论文2015</li>
<li>《再探快速傅里叶变换》毛啸，IOI中国国家候选队论文2016</li>
<li><a href="https://rqy.moe/Math/gf_correct/">《浅谈 OI 中常用的一些生成函数运算的合法与正确性》</a>，rpy’s Blog</li>
</ul>
<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol>
<li><a href="https://loj.ac/p/2271">「SDOI2017」遗忘的集合</a></li>
<li><a href="http://codeforces.com/problemset/problem/923/E">「CF923E」Perpetual Subtraction</a></li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>ICPC 补题</title>
    <url>/post/icpc-buti/</url>
    <content><![CDATA[<p>我是申必是怎么回事呢？神笔相信大家都很熟悉，但是为什么我是沈璧呢？下面就让小编带大家一起了解吧。<br>我是神必，其实就是是伸臂了。那么我为什么会是沈比，相信大家都很好奇是怎么回事。大家可能会感到很惊讶，我怎么会是沈璧呢？但事实就是这样，小编也感到非常惊讶。</p>
<h4 id="EC-Final-西安"><a href="#EC-Final-西安" class="headerlink" title="EC Final 西安"></a>EC Final 西安</h4><p><strong>B</strong></p>
<p>考虑一个子串的合法划分形如：$[…]A|ABC|AB[…]$。</p>
<p>考虑枚举两道竖线的位置 $i,j$，那么 $AB$ 是 $s[i:],s[j:]$ 的公共前缀。</p>
<p>考虑如果 $len&#x3D;|AB|$ 确定，那么 $AB$ 可以唯一确定，此时的贡献是 $\sum_{k&#x3D;1}^{len-1}[s[i:i+k-1]&#x3D;s[i-k:i-1]]$。</p>
<p>显然 $len$ 是连续取值的，$2\le len\le LCP(s[i:], s[j:])$。</p>
<p>任意两个后缀的 LCP 可以 $O(n^2)$ DP，或者 z 函数。</p>
<p>定义一个 $c[i,l]&#x3D;[s[i:i+l-1]&#x3D;s[i-l:i-1]]$，那么 $i,j$ 的贡献实际上就是 $c$ 数组的二阶前缀和。</p>
<h4 id="ICPC-杭州"><a href="#ICPC-杭州" class="headerlink" title="ICPC 杭州"></a>ICPC 杭州</h4><p><strong>A</strong></p>
<p>给出 $H, n, m$，求一个 $s,d\in \mathbb R$ 使得 $H+ns+\frac {n(n+1)} 2d \text{ mod }m$ 最小。</p>
<p>把 $d$ 写成 $2k+t(t&#x3D;0 \text{ or }1)$ 的形式，然后发现 $\frac {n(n+1)} 2 d&#x3D;\frac {n(n+1)} 2t+ n(n+1)k$ ，后一项提一个 $(n+1)k$ 之后可以与 $s$ 合并。</p>
<p>也就是 $d$ 只取 0 或 1。两种问题本质上没有区别，那么考虑使 $H+ns\text{ mod }m$ 最小。</p>
<p>考虑 $ns\text{ mod }m$ 的所有取值是 $k(n,m),0\le k&lt; m&#x2F;(n,m)$。</p>
<p>记 $B &#x3D; m-H$，显然 $ns\ge B$ 才是有效的，且我们要找到最小的 $ns$ 使得 $ns&#x3D;k(n,m)\ge B$。</p>
<p>显然 $k&#x3D;\lceil B&#x2F;(n,m)\rceil$，剩下的问题是解同余方程 $ns\equiv (n,m)k\text{ (mod }m)$，exgcd 即可。</p>
<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;y)</span></span>&#123;
    <span class="hljs-keyword">if</span>(!b) <span class="hljs-keyword">return</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>, a;
    <span class="hljs-type">int</span> g = <span class="hljs-built_in">exgcd</span>(b, y, a % b, x);
    <span class="hljs-keyword">return</span> y -= (a / b) * x, g;
&#125;</code></pre>

<h4 id="CCPC-绵阳"><a href="#CCPC-绵阳" class="headerlink" title="CCPC 绵阳"></a>CCPC 绵阳</h4><p><strong>A</strong></p>
<p>博弈 DP，有待复盘：</p>
<p><a href="https://codeforces.com/gym/104065/problem/A">https://codeforces.com/gym/104065/problem/A</a></p>
<p><a href="https://atcoder.jp/contests/abc195/tasks/abc195_e">https://atcoder.jp/contests/abc195/tasks/abc195_e</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2964">https://www.luogu.com.cn/problem/P2964</a></p>
<h4 id="CCPC-广州-jly题"><a href="#CCPC-广州-jly题" class="headerlink" title="CCPC 广州 jly题"></a>CCPC 广州 jly题</h4><p><strong>M</strong></p>
<p>设长度为 $K$ 的序列 $a$，使 $0\le a_i\le m$，且 $\sum\limits_{1\le i&lt;j\le n} a_i \text{ XOR } a_j&#x3D;n$，求 $a$ 的个数。</p>
<p>数位 DP，首先要卡 $m$ 的限制那么从高位向低位做，设 $f[i,j,k]$ 表示考虑高 $i$ 位，现有 $j$ 个数字卡了上界，第 $0\sim i$ 位（未确定的位）两两异或的贡献之和应等于 $2^k$ 的方案数。</p>
<p>先看一下 $k$ 的界，首先 $k\le (K&#x2F;2)^2$，因为更大的情况是无法表示的。</p>
<p>那么看下能不能转移，考虑 $f[i,j,k]$ 应该往哪里转移。</p>
<p>如果 $m$ 的 $i+1$ 位为 0，那么这种情况是简单的，因为高 $i$ 位卡上界的数字此时依然卡上界。枚举不卡上界的数字有 $j_1$ 个为 1（$0\le j_1\le K -j$），转移是：</p>
<p>$$f[i,j,k]\binom{j-K}{j_1}\to f[i+1,j,2k-j_1(K-j_1)]$$</p>
<p>注意这里 $0\le 2k-j_1(K-j_1)\le(K&#x2F;2)^2$。</p>
<p>然后如果 $m$ 的 $i+1$ 位为 1，分别枚举 $0\le j_1\le K-j$ 和 $0\le j_2\le j$ 表示没卡上界和卡上界的数字，分别选了多少个 1，转移是：</p>
<p>$$ f[i,j,k]\binom{K-j}{j_1}\binom{j}{j_2}\to f[i+1,j_2,2k-(j_1+j_2)(K-j_1-j_2)] $$</p>
<p>状态数 $O(\dfrac{K^3\log n} 4)$，转移至多  $O(K^2)$，这样是 $O(\dfrac{K^5\log n} 4)$，可过。</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL; <span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
LL n, m, K, ub, C[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>], f[<span class="hljs-number">2</span>][<span class="hljs-number">20</span>][<span class="hljs-number">400</span>];
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getub</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-type">int</span> i = <span class="hljs-number">50</span>;
    <span class="hljs-keyword">while</span>(i &amp;&amp; !(n &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i)) &amp;&amp; !(m &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i))) i--;
    <span class="hljs-keyword">return</span> i;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;_in.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);
    C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = C[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = C[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">18</span>; i++)&#123;
        C[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) C[i][j] = (C[i - <span class="hljs-number">1</span>][j] + C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % P;
    &#125;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;K), ub = <span class="hljs-built_in">getub</span>();
    f[<span class="hljs-number">0</span>][K][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> B = (K / <span class="hljs-number">2</span>) * (K - K / <span class="hljs-number">2</span>), ans = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= ub; i++)&#123;
        <span class="hljs-type">int</span> u = (i &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>, p = i &amp; <span class="hljs-number">1</span>, cb = ub - i; <span class="hljs-built_in">memset</span>(f[u], <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f[u]));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= K; j++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= B; k++)&#123;
                <span class="hljs-type">int</span> sk = <span class="hljs-number">2</span> * k + !!(n &amp; (<span class="hljs-number">1ll</span> &lt;&lt; cb));
                <span class="hljs-keyword">if</span>(m &amp; (<span class="hljs-number">1ll</span> &lt;&lt; cb))&#123;
                    <span class="hljs-comment">// f[p][j][u] * C[k - j][j1] * C[j][j2]-&gt; f[u][j2][su - (j1 + j2) * (k - j1 - j2)]</span>
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = <span class="hljs-number">0</span>; j1 &lt;= K - j; j1++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j2 = <span class="hljs-number">0</span>; j2 &lt;= j; j2++)&#123;
                        <span class="hljs-type">int</span> cnt = (j1 + j2) * (K - j1 - j2); <span class="hljs-keyword">if</span>(sk &lt; cnt || sk - cnt &gt; B) <span class="hljs-keyword">continue</span>;
                        f[u][j2][sk - cnt] = ((LL)C[K - j][j1] * C[j][j2] % P * f[p][j][k] + f[u][j2][sk - cnt]) % P;
                    &#125;
                &#125;
                <span class="hljs-keyword">else</span>&#123;
                    <span class="hljs-comment">// f[p][j][u] * C[k - j][j1] -&gt; f[u][j][su - j1 * (k - j1)]</span>
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j1 = <span class="hljs-number">0</span>; j1 &lt;= K - j; j1++)&#123;
                        <span class="hljs-type">int</span> cnt = j1 * (K - j1); <span class="hljs-keyword">if</span>(sk &lt; cnt || sk - cnt &gt; B) <span class="hljs-keyword">continue</span>;
                        f[u][j][sk - cnt] = ((LL)C[K - j][j1] * f[p][j][k] + f[u][j][sk - cnt]) % P;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    ub = ub &amp; <span class="hljs-number">1</span>, ub ^= <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= K; j++) ans = (ans + f[ub][j][<span class="hljs-number">0</span>]) % P;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h4 id="鹿赛-23"><a href="#鹿赛-23" class="headerlink" title="鹿赛 23"></a>鹿赛 23</h4><p><strong>HDU 6900</strong></p>
<p>没米恰，咕了</p>
]]></content>
      <categories>
        <category>CP 笔记</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
      </tags>
  </entry>
</search>
