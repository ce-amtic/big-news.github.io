<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/post/helloworld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>template 的构建</title>
    <url>/post/template/</url>
    <content><![CDATA[<h2 id="形式幂级数与生成函数"><a href="#形式幂级数与生成函数" class="headerlink" title="形式幂级数与生成函数"></a>形式幂级数与生成函数</h2><h3 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h3><p>设 $z$ 是未定元，我们定义一个形式幂级数是一个无穷级数：</p>
<p>$$ A(z)&#x3D;a_0+a_1z^1+a_2z^2+…+a_nz^n+…&#x3D;\sum\limits_{i\ge 0} a_iz^i $$</p>
<p>其中 $\langle a_0,a_1,a_2,…\rangle$ 是一个无穷的实系数序列。</p>
<p>在这里，我们并不关心 $z$ 是否代入了某个值，它如同一个“占位符”，并不参与我们的运算。</p>
<h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><p>对于任意一个序列 $\langle g_0,g_1,g_2,…,g_n\rangle$，我们可以认为其不存在的项全部等于 0，然后将其看作一个无穷的数列。这样，我们可以定义这个数列的普通生成函数（Ordinary Generating Function, OGF）是一个形式幂级数：</p>
<p>$$G(z)&#x3D;\sum\limits_{i\ge 0} g_iz^i$$</p>
<p>可以定义这个数列的指数生成函数（Exponential Generating Funcion, EGF）是一个形式幂级数：</p>
<p>$$G(z)&#x3D;\sum\limits_{i\ge 0} \dfrac{g_iz^i}{i!}$$</p>
<p>这样我们就通过统一化的语言来表达了一个数列，而这就是生成函数的意义所在：解决数列问题的工具。</p>
<p>从另一种角度来讲，生成函数也可以看作一个次数是正无穷的多项式，因此生成函数的乘法即是多项式相乘。</p>
<p>一般情况下，我们只关心某个生成函数的前 $n$ 项系数，记作 $A(z)\text{ }\text{mod}\text{ } z^n$。这个形式对应了一个有限项的系数序列。</p>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="乘法卷积"><a href="#乘法卷积" class="headerlink" title="乘法卷积"></a>乘法卷积</h3><p>对于数列 $f,g$，我们定义它们的乘法卷积（或者直接称作卷积）是一个数列 $c$，满足：</p>
<p>$$ c_i&#x3D;\sum\limits_{j&#x3D;0}^i f_jg_{i-j}$$</p>
<p>同时记作 $c&#x3D;fg$。容易发现，两个数列乘法卷积的 OGF 是它们各自的 OGF 相乘得到的结果。</p>
<h3 id="二项卷积"><a href="#二项卷积" class="headerlink" title="二项卷积"></a>二项卷积</h3><p>对于数列 $f,g$，我们定义它们的二项卷积是一个数列 $c$，满足：</p>
<p>$$c_i&#x3D;\sum\limits_{j&#x3D;0}^i \dbinom{i}{j}f_jg_{i-j}$$</p>
<p>同时记作 $c&#x3D;fg$，这里乘法的定义与上面的不同，但是惯用记号一样，需要根据语境来区分。容易发现，两个数列二项卷积的 EGF 是它们的 EGF 相乘得到的结果。</p>
<h3 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h3><p>对于数列 $f,g$，我们定义它们的狄利克雷卷积是一个数列 $c$，满足：</p>
<p>$$c_i&#x3D;\sum\limits_{k|i} f_{k}g_{i&#x2F;k}$$</p>
<p>记号同上。狄利克雷卷积在数论中很常见。</p>
<p>类似的，我们可以定义异或卷积 $(fg)_i&#x3D;\sum\limits_{j\oplus k&#x3D;i} f_jg_k$，或卷积 $(fg)_i&#x3D;\sum\limits_{j\cup k&#x3D;i}f_jg_k$，与卷积 $(fg)_i&#x3D;\sum\limits_{j\cap k&#x3D;i} f_jg_k$，其中我们用 $\oplus$ 代表按位异或，用 $\cup$ 代表按位或，用 $\cap$ 代表按位与。</p>
<p>除去狄利克雷卷积可以直接 $O(n\ln n)$ 计算之外，其它卷积计算的朴素实现均是 $O(n^2)$ 的。因此我们需要通过下面的这些手段去计算卷积。</p>
<h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>离散傅里叶变换（Discrete Fourier Transform, DFT）是对多项式进行从系数表示到点值表示的变换。设 $f(x)$ 是一个 $n-1$ 次多项式，那么它的 DFT 对应一个长度为 $n$ 的序列 $\mathcal F(f)$，满足：</p>
<p>$$ \mathcal F(f)_i&#x3D;f(x_i) $$</p>
<p>其中 $x_i(i&#x3D;0,1,2,…,n-1)$ 是代入的点值。</p>
<p>快速傅里叶变换（Fast Fourier Transform, FFT）通过 $n$ 次单位根 $\omega_n$ 来进行 DFT，其中 $\omega_n$ 满足 $\omega_n^n&#x3D;1$；在复数域下，这样的数字一共有 $n$ 个。<br>如果令 $\omega_n^1&#x3D;\cos \frac{2\pi}{n}+i\sin\frac{2\pi}{n}$，那么它们分别是 $\omega_n^0,\omega_n^1,\omega_n^2,…,\omega_n^{n-1}$。</p>
<p>由于 $n$ 次单位根的一些特殊性质，所以当 $n&#x3D;2^k$ 时，我们可以通过分治来求解点值，以及通过点值来求解系数，后者称作逆变换（Inverse Discrete Fourier Transfrom, IDFT）。</p>
<p>这样就得到了一个在 $O(n\log n)$ 的时间内进行 DFT 的算法（FFT）。需要注意的一点是，如果用 FFT 计算序列卷积，得到的是长度为 $n$ 的循环卷积 $(fg)_i&#x3D;\sum\limits_{j+k\text{ }\text{mod }n&#x3D;i}f_jg_k$，用生成函数记作：</p>
<p>$$F(z)G(z)\text{ }\text{mod }z^n-1$$</p>
<p>FFT 的代码实现可以在模板梳理中找到。</p>
<h3 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h3><ul>
<li>原根：在 $\mathbb F_R$ 下，如果一个数 $g^i$ 一共有 $\varphi(R)$ 种不同的取值，或者说 $g$ 模 $R$ 的阶是 $\varphi(R)$，那么称 $g$ 是 $\mathbb F_R$ 下的原根。</li>
</ul>
<p>可以证明，原根存在的充要条件是 $R&#x3D;2,4,p^a,2p^a$，其中 $p$ 是一个素数。可以发现，素数的原根是总存在的。</p>
<p>考虑做长度为 $n&#x3D;2^k$ 的 DFT，有没有什么方式可以避免复数运算？</p>
<p>对于形如 $P&#x3D;a2^r+1(r\ge k)$ 的素数，设 $g$ 是 $\mathbb F_P$ 下的原根，那么 $g_n&#x3D;g^{\varphi(P)&#x2F;n}$ 有着与 $n$ 次单位根 $\omega_n$ 相同的性质，即 $g_n^n&#x3D;1$。根据原根的性质，我们可以发现 $g_n^0,g_n^1,…,g_n^{n-1}$ 是 $n$ 个两两不同的数字，且都满足 $(g_n^l)^n\equiv g^{l\varphi(P)}\equiv 1\text{ }(\text{mod }P)$。于是，我们可以用 $g_n$ 来代替 $\omega_n$ 进行多项式变换，这样就得到了快速数论变换，本质上是 FFT 在模域下的变种。</p>
<p>一个质数的原根一定存在，但并不是只要存在原根就可以 NTT，另一个条件是 $n|\varphi(P)$，形象的理解即可以等分圆周。</p>
<p>代码同样可以在模板梳理中找到。</p>
<p>值得一提的是，这种计算点值的方法与单位根反演有着异曲同工之妙。单位根反演即是这个柿子：</p>
<p>$$[k|n]&#x3D;\dfrac{1}{k}\sum\limits_{i&#x3D;0}^{k-1}\omega_k^{in}$$</p>
<p>其中 $\omega_k$ 是 $k$ 次单位根，模义下可用 $g_k$ 来代替；这可以看作是计算了一个点值，在一些题目中会具有优良的性质。</p>
<h3 id="离散沃尔什变换"><a href="#离散沃尔什变换" class="headerlink" title="离散沃尔什变换"></a>离散沃尔什变换</h3><p>显然，位运算卷积不满足卷积结果的点值是原点值相乘。那么我们可以通过一些手段构造某种变换，来让我们变换出的序列满足点值相乘的规律。这些变换分别是：</p>
<ul>
<li>按位或</li>
</ul>
<p>$$\mathcal{F}(f)_i&#x3D;\sum\limits_{j\cup i&#x3D;i}a_j$$</p>
<ul>
<li>按位与</li>
</ul>
<p>$$\mathcal{F}(f)_i&#x3D;\sum\limits_{j\cap i&#x3D;i}a_j$$</p>
<ul>
<li>按位异或</li>
</ul>
<p>$$\mathcal{F}(f)_i&#x3D;\sum\limits_{j&#x3D;0}^{n-1} (-1)^{|i\cap j|} f_j$$</p>
<p>其中 $|x|$ 代表 $x$ 在二进制下为 1 的位数。可以证明，这些变换满足与 DFT 同样的性质，即点值的乘积是卷积结果的点值。</p>
<p>对于异或的变换，还有一个重要的柿子是 $\mathcal{F}(\mathcal{F}(f))_i&#x3D;n·f_i$，可以通过代入化简来证明。</p>
<p>这些变换都可以通过类似 FFT 的方法在 $O(n\log n)$ 的时间内得到。代码可以参考模板梳理。</p>
<h2 id="3-微积分"><a href="#3-微积分" class="headerlink" title="3 微积分"></a>3 微积分</h2><p>形式幂级数的微分定义为逐项微分，即：</p>
<p>$$\dfrac{\text d}{\text dz} \left(\sum\limits_{i\ge 0} a_iz^i \right)&#x3D;\sum\limits_{i\ge 0} (i+1)a_{i+1}z^i$$</p>
<p>同样的，形式幂级数的积分定义为逐项积分。我们可以定义一个形式幂级数的定积分为：</p>
<p>$$\int \left(\sum\limits_{i\ge 0}a_iz^i \right)\text dz&#x3D;\sum\limits_{i&gt;0}\dfrac{a_{i-1}}{i}z^i$$</p>
<p>我们可以用微积分来分析一个幂级数的闭合形式，这在涉及指标变换的时候较为方便。</p>
<h2 id="乘法逆"><a href="#乘法逆" class="headerlink" title="乘法逆"></a>乘法逆</h2><p>对于幂级数 $A(z)$，我们定义它的乘法逆是一个幂级数 $B(z)$ 满足 $A(z)B(z)\equiv 1 \text{ }(\text{mod } z^n)$，记作 $B(z)&#x3D;A^{-1}(z)$。</p>
<p>当 $A(z)$ 的常数项不为零时，它的乘法逆是总存在的。证明如下：</p>
<p>设 $A(z)&#x3D;\sum\limits_{i&#x3D;0}^{n-1} a_ix^i, B(z)&#x3D;\sum\limits_{i&#x3D;0}^{n-1} b_ix^i$，通过乘法逆的定义可得：</p>
<p>$$\begin{align} &amp;b_0&#x3D;\dfrac{1}{a_0}\newline &amp;\sum\limits_{j&#x3D;1}^{n-1} a_jb_{i-j}&#x3D;0\text{ }(i&gt;0)\end{align}$$</p>
<p>对 $i$ 归纳可以得到：</p>
<p>$$ b_i&#x3D;-b_0\sum\limits_{j&#x3D;0}^{i-1}a_{i-j}b_j\text{ }(i&gt;0) $$</p>
<p>从而只要 $b_0$ 存在就可以构造出 $B(z)$。同时这也给出了朴素 $O(n^2)$ 求逆的方法，下一步考虑怎么优化。</p>
<p>设 $B_0(z)&#x3D;A^{-1}(z)\text{ }\text{mod } z^n$ 是一个只有前 $n$ 项系数有效的幂级数，可以如下倍增：</p>
<p>$$\begin{align} B_0(z)A(z)&amp;\equiv 1\text{ }(\text{mod } z^n)\newline    (B_0(z)A(z)-1)^2&amp;\equiv 0\text{ }(\text{mod }z^{2n})\newline    B_0^2(z)A^2(z)-2B_0(z)A(z)+1&amp;\equiv 0\text{ }(\text{mod }z^{2n}) \newline    B_0(z)(2-B_0(z)A(z))&amp;\equiv B(z)\text{ }(\text{mod }z^{2n}) \end{align}$$</p>
<p>其中 $B(z)&#x3D;A^{-1}(z)\text{ }\text{mod } z^{2n}$ 是一个只有前 $2n$ 项系数有效的幂级数。</p>
<p>依此倍增，复杂度 $T(n)&#x3D;T(n&#x2F;2)+O(n\log n)&#x3D;O(n\log n)$，实现可以在代码梳理中找到。</p>
<h2 id="指对运算"><a href="#指对运算" class="headerlink" title="指对运算"></a>指对运算</h2><h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><p>对一个高阶可导的函数 $f(x)$，它在 $x&#x3D;x_0$ 处的泰勒展开式为：</p>
<p>$$f(x)&#x3D;f(x_0)+f’(x_0)(x-x_0)+\dfrac{f’’(x_0)(x-x_0)^2}{2}+…+\dfrac{f^{(n)}(x-x_0)^n}{n!}+…$$</p>
<p>这是一个无穷级数。也可以只保留前 $n+1$ 项写作：</p>
<p>$$f(x)&#x3D;f(x_0)+f’(x_0)(x-x_0)+\dfrac{f’’(x_0)(x-x_0)}{2}+…+\dfrac{f^{(n)}(x_0)}{n!}+r_n(x)$$</p>
<p>其中 $r_n(x)$ 指代一个余项。</p>
<h3 id="麦克劳林公式"><a href="#麦克劳林公式" class="headerlink" title="麦克劳林公式"></a>麦克劳林公式</h3><p>在泰勒展开的公式中，取 $x_0&#x3D;0$，就得到了麦克劳林公式：</p>
<p>$$f(x)&#x3D;f(0)+f’(0)x+\dfrac{f’’(0)x^2}{2!}+…+\dfrac{f^{(n)}(0)x^n}{n!}+…$$</p>
<p>亦即 $f(x)$ 在 $x&#x3D;0$ 处的泰勒展开。</p>
<p>形式幂级数的乘方是有定义的，那么我们可以通过泰勒展开来定义如何对形式幂级数进行各种诡异的函数变换，诸如指对函数，正余弦函数，等等。</p>
<h3 id="指数函数和对数函数"><a href="#指数函数和对数函数" class="headerlink" title="指数函数和对数函数"></a>指数函数和对数函数</h3><p>由于 $(e^x)’&#x3D;e^x$，根据麦克劳林公式，可以得到：</p>
<p>$$\exp x&#x3D;e^x&#x3D;1+x+\dfrac{x^2}{2!}+\dfrac{x^3}{3!}…$$ </p>
<p>这是一个无穷级数。于是可以定义一个形式幂级数的指数函数为：</p>
<p>$$\exp A(z)&#x3D;\sum\limits_{i\ge 0}\dfrac{A^i(z)}{i!}$$</p>
<p>同理，因为：</p>
<p>$$\ln’ x&#x3D;x^{-1},\ln &#39;&#39;x&#x3D;-x^{-2},…,,\ln^{(n)} x&#x3D;(-1)^{n-1}(n-1)!(1+x)^{-n}$$</p>
<p>可以定义一个形式幂级数的对数函数是：</p>
<p>$$\ln (1+A(z))&#x3D;-\sum\limits_{i&gt;0}\dfrac{(-1)^iA^i(z)}{i}$$</p>
<p>注意这里的常数项是未定义的，一般认为其等于 0。</p>
<p>考虑如何求对数函数。设 $B(z)&#x3D;\ln A(z)$，两边求导得到：</p>
<p>$$B’(z)&#x3D;\ln’ A(z)&#x3D;\dfrac{A’(z)}{A(z)}$$</p>
<p>即是链式法则。于是我们只需要求逆即可，复杂度 $O(n\log n)$。</p>
<p>多项式指数的计算需要用到牛顿迭代。</p>
<h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>考虑计算一个函数 $f(x)$ 的零点。设 $x_0$ 是一个已知的近似解，在 $x_0$ 处对 $f(x)$ 泰勒展开，可以得到 $f(x)$ 的一个近似表达：</p>
<p>$$ f(x)\sim f(x_0)+f’(x_0)(x-x_0) $$</p>
<p>令 $f(x_0)+f’(x_0)(x-x_0)&#x3D;0$，解得 $x&#x3D;x_0-\dfrac{f(x_0)}{f’(x_0)}$。取 $x$ 作为下一个近似解 $x_2$，又可以进行同样的操作。可以证明，在某些情况下，这样就可以逼近 $f(x)$ 精确的零点。</p>
<p>设 $B(z)&#x3D;\exp A(z)$，那么有 $\ln B(z)-A(z)&#x3D;0$。设 $G(B(z))&#x3D;\ln B(z)-A(z)$ 是一个以 $B(z)$ 为变元的形式幂级数，$B_0(z)&#x3D;\exp A(z)\text{ }\text{mod }z^n$ 是已知的近似解，那么可以如下倍增（迭代）：</p>
<p>$$\begin{align} B(z)&amp;\equiv B_0(z)-\dfrac{\ln B_0(z)-A(z)}{1&#x2F;B_0(z)}\text{ }(\text{mod } z^{2n})\newline    &amp;\equiv B_0(z)(1-\ln B_0(z)+A(z))\text{ }(\text{mod } z^{2n})\end{align}$$</p>
<p>依此迭代，复杂度 $T(n)&#x3D;T(n&#x2F;2)+O(n\log n)&#x3D;O(n\log n)$，实现可以在代码梳理中找到。</p>
<h2 id="6-应用"><a href="#6-应用" class="headerlink" title="6 应用"></a>6 应用</h2><h3 id="一道栗题"><a href="#一道栗题" class="headerlink" title="一道栗题"></a>一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>请构造一个序列 $a_1,a_2,…,a_k$，满足 $\forall i\in[1, k] a_i\in[1, n]$，使得对这个序列做无限背包计数后得到的序列的前 $n$ 项在模 $P$ 意义下是 $f_1,f_2,…,f_n$，其中 $P$ 是一个给定的质数。序列的长度没有限制，可以证明解总存在且唯一。</p>
<p>$n\le 2^{18},10^6\le p\le 2^{30}$</p>
</div></article>

<p>设 $b_i$ 表示序列中是否包含 $i$ 这个数字，$F(z)&#x3D;\sum\limits_{i&#x3D;1}^n f_iz^i$，那么有：</p>
<p>$$\begin{align} F(z)&amp;&#x3D;\prod\limits_{i&#x3D;1}^n \dfrac{1}{(1-z^i)^{b_i}}\newline    \ln F(z)&amp;&#x3D;-\sum\limits_{i&#x3D;1}^nb_i\ln(1-z^i)\newline    \ln F(z)&amp;&#x3D;\sum\limits_{i&#x3D;1}^nb_i\sum\limits_{j&gt;0}\dfrac{z^{ij}}{j}\newline    &amp;&#x3D;\sum\limits_{i&#x3D;1}^n z^i\sum\limits_{j|i}\dfrac{jb_j}{i}  \end{align}$$</p>
<p>比较系数得 $nf_n&#x3D;\sum\limits_{i|n}ib_i$，亦即 $f&#x3D;b*1$，莫比乌斯反演得 $b_n&#x3D;\dfrac{1}{n}\sum\limits_{j|n}jf_j\varphi(n&#x2F;j)$。</p>
<p>复杂度 $O(n(\log n+\ln n))$，需要任意模数卷积，这里用拆系数 FFT 实现。</p>
<p>代码：</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LDB long double</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> CN = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">18</span>) + <span class="hljs-number">3</span>;
<span class="hljs-type">const</span> LDB PI = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);
<span class="hljs-type">int</span> P;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>, ne = <span class="hljs-number">1</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">for</span>(;c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) ne = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(;c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) s = (s &lt;&lt; <span class="hljs-number">1</span>) + (s &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-string">&#x27;0&#x27;</span>;
    <span class="hljs-keyword">return</span> s * ne;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;
    <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; 
    <span class="hljs-keyword">while</span>(b)&#123;
        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) r = <span class="hljs-number">1ll</span> * r * a % P;
        a = <span class="hljs-number">1ll</span> * a * a % P, b &gt;&gt;= <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> r;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">invx</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x, P - <span class="hljs-number">2</span>);&#125;
<span class="hljs-keyword">namespace</span> POLY&#123;
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">COMP</span>&#123;
        <span class="hljs-keyword">public</span>: LDB x, y;
        COMP <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> COMP &amp;o) <span class="hljs-type">const</span>&#123;
            COMP r = *<span class="hljs-keyword">this</span>; r.x += o.x, r.y += o.y;
            <span class="hljs-keyword">return</span> r;
        &#125;
        COMP <span class="hljs-keyword">operator</span> - (<span class="hljs-type">const</span> COMP &amp;o) <span class="hljs-type">const</span>&#123;
            COMP r = *<span class="hljs-keyword">this</span>; r.x -= o.x, r.y -= o.y;
            <span class="hljs-keyword">return</span> r;
        &#125;
        COMP <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> COMP &amp;o) <span class="hljs-type">const</span>&#123;
            COMP r; r.x = x * o.x - y * o.y, r.y = x * o.y + y * o.x;
            <span class="hljs-keyword">return</span> r;
        &#125;
    &#125; ;
    <span class="hljs-function">COMP <span class="hljs-title">mk</span><span class="hljs-params">(LDB a, LDB b)</span> </span>&#123;COMP o; o.x = a, o.y = b; <span class="hljs-keyword">return</span> o;&#125;
    <span class="hljs-function">COMP <span class="hljs-title">conj</span><span class="hljs-params">(COMP o)</span> </span>&#123;o.y = -o.y; <span class="hljs-keyword">return</span> o;&#125;
    <span class="hljs-type">int</span> rev[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cg</span><span class="hljs-params">(COMP t[], <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (n &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">if</span>(i &lt; rev[i]) <span class="hljs-built_in">swap</span>(t[i], t[rev[i]]);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(COMP t[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> tp)</span></span>&#123;
        <span class="hljs-built_in">cg</span>(t, n); 
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt;= n; w &lt;&lt;= <span class="hljs-number">1</span>)&#123;
            <span class="hljs-type">int</span> l = w &gt;&gt; <span class="hljs-number">1</span>; COMP gn = <span class="hljs-built_in">mk</span>(<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * PI / (LDB)w), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * tp * PI / (LDB)w));
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += w)&#123;
                COMP g = <span class="hljs-built_in">mk</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; i + l; j++)&#123;
                    COMP u = t[j], v = t[j + l] * g;
                    t[j] = u + v, t[j + l] = u - v, g = g * gn;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(tp ^ <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) t[i].x /= (LDB)n, t[i].y /= (LDB)n;
        &#125;
    &#125;
    COMP p[CN &lt;&lt; <span class="hljs-number">2</span>], q[CN &lt;&lt; <span class="hljs-number">2</span>], x[CN &lt;&lt; <span class="hljs-number">2</span>], y[CN &lt;&lt; <span class="hljs-number">2</span>], z[CN &lt;&lt; <span class="hljs-number">2</span>], w[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">conv</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// a = a * b</span>
        <span class="hljs-type">int</span> B = (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>) - <span class="hljs-number">1</span>, N = <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(N &lt; (n &lt;&lt; <span class="hljs-number">1</span>)) N &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) p[i] = q[i] = <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); 
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p[i] = <span class="hljs-built_in">mk</span>(a[i] &gt;&gt; <span class="hljs-number">15</span>, a[i] &amp; B); <span class="hljs-comment">// k1 r1</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) q[i] = <span class="hljs-built_in">mk</span>(b[i] &gt;&gt; <span class="hljs-number">15</span>, b[i] &amp; B); <span class="hljs-comment">// k2 r2</span>
        <span class="hljs-built_in">fft</span>(p, N, <span class="hljs-number">1</span>), <span class="hljs-built_in">fft</span>(q, N, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;
            <span class="hljs-type">int</span> j = (N - <span class="hljs-number">1</span>) &amp; (N - i);
            COMP k1, r1, k2, r2;
            k1 = (p[i] + <span class="hljs-built_in">conj</span>(p[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>);
            r1 = (p[i] - <span class="hljs-built_in">conj</span>(p[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-0.5</span>);
            k2 = (q[i] + <span class="hljs-built_in">conj</span>(q[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>);
            r2 = (q[i] - <span class="hljs-built_in">conj</span>(q[j])) * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-0.5</span>);
            x[i] = k1 * k2, y[i] = r1 * r2, z[i] = k1 * r2, w[i] = k2 * r1;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) p[i] = x[i] + y[i] * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) q[i] = z[i] + w[i] * <span class="hljs-built_in">mk</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
        <span class="hljs-built_in">fft</span>(p, N, <span class="hljs-number">-1</span>), <span class="hljs-built_in">fft</span>(q, N, <span class="hljs-number">-1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;
            LL X = (LL)(<span class="hljs-number">0.5</span> + p[i].x), Y = (LL)(<span class="hljs-number">0.5</span> + p[i].y), Z = (LL)(<span class="hljs-number">0.5</span> + q[i].x), W = (LL)(<span class="hljs-number">0.5</span> + q[i].y);
            X = (X % P + P) % P, Y = (Y % P + P) % P, Z = (Z % P + P) % P, W = <span class="hljs-built_in">add</span>((W % P + P) % P, Z);
            a[i] = <span class="hljs-built_in">add</span>((X &lt;&lt; <span class="hljs-number">30</span>) % P, <span class="hljs-built_in">add</span>((W &lt;&lt; <span class="hljs-number">15</span>) % P, Y));
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &lt; N; i++) a[i] = <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-type">int</span> c[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n &lt;&lt; <span class="hljs-number">1</span>); i++) b[i] = c[i] = <span class="hljs-number">0</span>;
        b[<span class="hljs-number">0</span>] = <span class="hljs-built_in">invx</span>(a[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt; (n &lt;&lt; <span class="hljs-number">1</span>); w &lt;&lt;= <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) c[i] = a[i];
            <span class="hljs-built_in">conv</span>(c, b, w);
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) c[i] = <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>, P - c[i]); c[<span class="hljs-number">0</span>] = <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, c[<span class="hljs-number">0</span>]);
            <span class="hljs-built_in">conv</span>(b, c, w);
        &#125;    
    &#125;
    <span class="hljs-type">int</span> ia[CN &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ln</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n &lt;&lt; <span class="hljs-number">1</span>); i++) ia[i] = b[i] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">inv</span>(a, ia, n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n &lt;&lt; <span class="hljs-number">1</span>); i++) c[i] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) c[i] = <span class="hljs-number">1ll</span> * (i + <span class="hljs-number">1</span>) * a[i + <span class="hljs-number">1</span>] % P;
        <span class="hljs-built_in">conv</span>(c, ia, n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) b[i] = <span class="hljs-number">1ll</span> * c[i - <span class="hljs-number">1</span>] * <span class="hljs-built_in">invx</span>(i) % P;
    &#125;
&#125;
<span class="hljs-type">int</span> p[CN], mu[CN]; <span class="hljs-type">bool</span> np[CN];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;
    np[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;
        <span class="hljs-keyword">if</span>(!np[i]) p[++p[<span class="hljs-number">0</span>]] = i, mu[i] = P - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= p[<span class="hljs-number">0</span>] &amp;&amp; i * p[j] &lt;= n; j++)&#123;
            <span class="hljs-type">int</span> x = i * p[j]; np[x] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(i % p[j]) mu[x] = P - mu[i];
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;
<span class="hljs-type">int</span> n, a[CN &lt;&lt; <span class="hljs-number">2</span>], b[CN &lt;&lt; <span class="hljs-number">2</span>]; 
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span>
    n = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>, P = <span class="hljs-built_in">read</span>();
    a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) a[i] = <span class="hljs-built_in">read</span>();
    POLY :: <span class="hljs-built_in">ln</span>(a, b, n);
    <span class="hljs-built_in">sieve</span>(n), <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) b[i] = <span class="hljs-number">1ll</span> * b[i] * i % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; i * j &lt; n; j++)
        a[i * j] = <span class="hljs-built_in">add</span>(a[i * j], <span class="hljs-number">1ll</span> * mu[i] * b[j] % P);
    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) cnt += (!!a[i]);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) <span class="hljs-keyword">if</span>(a[i]) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h3 id="又一道栗题"><a href="#又一道栗题" class="headerlink" title="又一道栗题"></a>又一道栗题</h3><article class="message is-primary" style="font-size:inherit"><div class="message-body">
<p>有一个整数 $x$，初值是 $[0,n]$ 内的一个随机值，其中为 $i$ 的概率为 $p_i$。<br>要进行 $m$ 轮操作，每次把 $x$ 等概率随机地替换成 $[0,x]$ 中的一个数字，求最后对 $\forall i\in[0, n]$，$x$ 的取值为 $i$ 的概率。对 $998244353$ 取模。</p>
<p>$n\le 10^5,m\le 10^{18}$</p>
</div></article>

<p>设 $f[k,i]$ 表示经过 $k$ 轮，得到 $i$ 的概率，有递推关系 $f[k,i]&#x3D;\sum\limits_{j\ge i}^n f[k-1,j]&#x2F;j+1$。</p>
<p>设 $F(k,z)&#x3D;\sum\limits_{i&#x3D;0}^n f[k,i]z^i$ 是 $f$ 的 OGF，根据上面的递推关系，有：</p>
<p>$$\begin{aligned} F(k,z)&amp;&#x3D;\sum\limits_{i&#x3D;0}^n z^i\sum\limits_{j&#x3D;i}^n \dfrac{f[k-1,j]}{j+1}\newline    &amp;&#x3D;\sum\limits_{j&#x3D;0}^n \dfrac{f[k-1,j]}{j+1}\sum\limits_{i&#x3D;0}^j z^i \newline  &amp;&#x3D;\dfrac{1}{z-1} \sum\limits_{i&#x3D;0}^n f[k-1,i]\dfrac{z^{i+1}-1}{i+1} \end{aligned}$$</p>
<p>考虑 $f[k-1,i]$ 转移到了哪里，容易发现它在 $F(k,·)$ 中是 $i+1$ 项系数，这个变换不容易快速实现，那么继续推导。</p>
<p>根据牛顿-莱布尼茨公式，可以推得：<br>$\int_1^z t^i\text{ }\text dt&#x3D;\dfrac{z^{i+1}}{z-1}-\dfrac{1}{z-1}$，那么原式化为：</p>
<p>$$\begin{aligned} F(k,z)&amp;&#x3D;\dfrac{1}{z-1}\sum\limits_{i&#x3D;0}^n f[k-1,i]\int_1^z t^i\text{ }\text dt\newline   &amp;&#x3D;\dfrac{1}{z-1}\int_1^z\left( \sum\limits_{i&#x3D;0}^nf[k-1,i]t^i\right)\text{ }\text dt\newline   &amp;&#x3D; \dfrac{1}{z-1}\int_1^z F(k-1,t)\text{ }\text dt  \end{aligned}$$</p>
<p>考虑原式中 $z^{i+1}-1$ 很是鬼畜，考虑把定积分的下指标改为从 0 开始，那么设 $G(k,z)&#x3D;F(k,z+1)$，有：</p>
<p>$$\begin{aligned} G(k,z)&amp;&#x3D;\dfrac{1}{z}\int_1^{z+1} F(k-1,t)\text{ }\text dt \newline   &amp;&#x3D;\dfrac{1}{z}\int_0^z F(k-1,t+1)\text{ }\text d(t+1)\newline   &amp;&#x3D;\dfrac{1}{z}\int_0^z G(k-1,t)\text{ }\text dt \newline    &amp;&#x3D; \dfrac{1}{z}\sum\limits_{i&#x3D;0}^n \dfrac{g[k-1,i]}{i+1}z^{i+1}\newline    &amp;&#x3D;\sum\limits_{i&#x3D;0}^n \dfrac{g[k-1,i]}{i+1}z^i \end{aligned}$$</p>
<p>其中 $g[k,i]$ 满足 $G(k,z)&#x3D;\sum\limits_{i&#x3D;0}^n g[k,i]z^i$，即是对应的序列。<br>考虑系数的变化：$k\to k+1:g[k,i]\to g[k+1,i]&#x2F;(i+1)$，那么 $m$ 次变化之后就是 $g[m,i]&#x3D;\dfrac{g[0,i]}{(i+1)^m}$ 这个就可以近似线性直接求出来。</p>
<p>那么只需要类似于 DFT 和 IDFT 那样子，把 $F$ 变成 $G$，系数修改完之后再变回来即可。</p>
<p>考虑怎么变，根据定义，得到：</p>
<p>$$\begin{aligned} G(k,z)&amp;&#x3D;F(k,z+1)\newline    \Leftrightarrow \sum\limits_{i&#x3D;0}^n g[k,i]z^i&amp;&#x3D;\sum\limits_{i&#x3D;0}^n f[k,i](z+1)^i\newline    &amp;&#x3D;\sum\limits_{i&#x3D;0}^n\sum\limits_{j&#x3D;0}^i\dbinom{i}{j}z^jf[k,i] \newline    &amp;&#x3D; \sum\limits_{i&#x3D;0}^n z^i \sum\limits_{j&#x3D;i}^n \dbinom{j}{i}f[k,j]\end{aligned}$$</p>
<p>考虑 $k&#x3D;0$，得：</p>
<p>$$\begin{aligned} g[0,i]&amp;&#x3D;\sum\limits_{j&#x3D;i}^n \dbinom{j}{i}p_j\newline    &amp;&#x3D; \dfrac{1}{i!}\sum\limits_{t&#x3D;0}^{n-i} \dfrac{(i+t)!p_{i+t}}{t!}\end{aligned}$$</p>
<p>这里是差为定值的卷积，依然可以化成序列卷积，那么构造 $A(z)&#x3D;\sum\limits_{i&#x3D;0}^n \dfrac{1}{i!},B(z)&#x3D;\sum\limits_{i&#x3D;0}^n b_ix^i$，其中有 $p_ii!&#x3D;b_{n-i}$，即人为令下标的和为定值，那么容易发现 $g[0,i]&#x3D;\dfrac{1}{i!}[z^{n-i}]A(z)B(z)$。NTT 即可，复杂度 $O(n\log n)$。</p>
<p>对于 $g\to f$ 的转化，根据二项式反演，有：</p>
<p>$$\begin{aligned} g[k,i]&amp;&#x3D;\sum\limits_{j&#x3D;i}^n\dbinom{j}{i}f[k,j] \newline    \Leftrightarrow f[k,i]&amp;&#x3D;\sum\limits_{j&#x3D;i}^n (-1)^{j-i}\dbinom{j}{i}g[k,j] \end{aligned}$$</p>
<p>依然是差为定值的卷积，同理可仿照上面求出，总复杂度 $O(n\log n)$。</p>
<p>代码：</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> LL long long</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> CN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;
<span class="hljs-function">LL <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;
    LL s = <span class="hljs-number">0</span>, ne = <span class="hljs-number">1</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">for</span>(;c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>) ne = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(;c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;c = <span class="hljs-built_in">getchar</span>()) s = (s &lt;&lt; <span class="hljs-number">1</span>) + (s &lt;&lt; <span class="hljs-number">3</span>) + c - <span class="hljs-string">&#x27;0&#x27;</span>;
    <span class="hljs-keyword">return</span> s * ne;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x + y &gt;= P ? x + y - P : x + y;&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;
    <span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(b)&#123;
        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) r = <span class="hljs-number">1ll</span> * r * a % P;
        a = <span class="hljs-number">1ll</span> * a * a % P, b &gt;&gt;= <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> r;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x, P - <span class="hljs-number">2</span>);&#125;
<span class="hljs-type">int</span> rev[CN &lt;&lt; <span class="hljs-number">2</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cg</span><span class="hljs-params">(<span class="hljs-type">int</span> t[], <span class="hljs-type">int</span> n)</span></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) rev[i] = (rev[i &gt;&gt; <span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">1</span>) + (i &amp; <span class="hljs-number">1</span>) * (n &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-keyword">if</span>(i &lt; rev[i]) <span class="hljs-built_in">swap</span>(t[i], t[rev[i]]);
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ntt</span><span class="hljs-params">(<span class="hljs-type">int</span> t[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> tp)</span></span>&#123;
    <span class="hljs-built_in">cg</span>(t, n);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">2</span>; w &lt;= n; w &lt;&lt;= <span class="hljs-number">1</span>)&#123;
        <span class="hljs-type">int</span> l = w &gt;&gt; <span class="hljs-number">1</span>, gn = <span class="hljs-built_in">qp</span>(tp ? <span class="hljs-number">3</span> : <span class="hljs-built_in">inv</span>(<span class="hljs-number">3</span>), (P - <span class="hljs-number">1</span>) / w);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += w)&#123;
            <span class="hljs-type">int</span> g = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; i + l; j++)&#123;
                <span class="hljs-type">int</span> u = t[j], v = <span class="hljs-number">1ll</span> * g * t[j + l] % P;
                t[j] = <span class="hljs-built_in">add</span>(u, v), t[j + l] = <span class="hljs-built_in">add</span>(u, P - v), g = <span class="hljs-number">1ll</span> * g * gn % P;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(!tp)&#123;
        <span class="hljs-type">int</span> in = <span class="hljs-built_in">inv</span>(n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) t[i] = <span class="hljs-number">1ll</span> * t[i] * in % P;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">conv</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// A = A * B</span>
    <span class="hljs-type">int</span> N = <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(N &lt; (n &lt;&lt; <span class="hljs-number">1</span>)) N &lt;&lt;= <span class="hljs-number">1</span>;
    <span class="hljs-built_in">ntt</span>(A, N, <span class="hljs-number">1</span>), <span class="hljs-built_in">ntt</span>(B, N, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) A[i] = <span class="hljs-number">1ll</span> * A[i] * B[i] % P;
    <span class="hljs-built_in">ntt</span>(A, N, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &lt; N; i++) A[i] = B[i] = <span class="hljs-number">0</span>;
&#125;
<span class="hljs-type">int</span> A[CN &lt;&lt; <span class="hljs-number">2</span>], B[CN &lt;&lt; <span class="hljs-number">2</span>];
<span class="hljs-type">int</span> n, m, p[CN], fac[CN], ifac[CN], g[CN];
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-comment">// freopen(&quot;_in.in&quot;, &quot;r&quot;, stdin);</span>
    n = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>, m = <span class="hljs-built_in">read</span>() % (P - <span class="hljs-number">1</span>);
    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) fac[i] = <span class="hljs-number">1ll</span> * fac[i - <span class="hljs-number">1</span>] * i % P;
    ifac[n - <span class="hljs-number">1</span>] = <span class="hljs-built_in">inv</span>(fac[n - <span class="hljs-number">1</span>]); <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i + <span class="hljs-number">1</span>; i--) ifac[i] = <span class="hljs-number">1ll</span> * ifac[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p[i] = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) A[n - i - <span class="hljs-number">1</span>] = <span class="hljs-number">1ll</span> * fac[i] * p[i] % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) B[i] = ifac[i];
    <span class="hljs-built_in">conv</span>(A, B, n); 
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) g[i] = <span class="hljs-number">1ll</span> * ifac[i] * A[n - i - <span class="hljs-number">1</span>] % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) g[i] = <span class="hljs-number">1ll</span> * g[i] * <span class="hljs-built_in">inv</span>(<span class="hljs-built_in">qp</span>(i + <span class="hljs-number">1</span>, m)) % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) A[n - i - <span class="hljs-number">1</span>] = <span class="hljs-number">1ll</span> * fac[i] * g[i] % P;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) B[i] = i &amp; <span class="hljs-number">1</span> ? P - ifac[i] : ifac[i];
    <span class="hljs-built_in">conv</span>(A, B, n);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">int</span>(<span class="hljs-number">1ll</span> * ifac[i] * A[n - i - <span class="hljs-number">1</span>] % P)); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《生成函数的运算与组合计数问题》金策，IOI中国国家候选队论文2015</li>
<li>《再探快速傅里叶变换》毛啸，IOI中国国家候选队论文2016</li>
<li><a href="https://rqy.moe/Math/gf_correct/">《浅谈 OI 中常用的一些生成函数运算的合法与正确性》</a>，rpy’s Blog</li>
</ul>
<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ol>
<li><a href="https://loj.ac/p/2271">「SDOI2017」遗忘的集合</a></li>
<li><a href="http://codeforces.com/problemset/problem/923/E">「CF923E」Perpetual Subtraction</a></li>
</ol>
]]></content>
      <tags>
        <tag>exmaple</tag>
      </tags>
  </entry>
</search>
